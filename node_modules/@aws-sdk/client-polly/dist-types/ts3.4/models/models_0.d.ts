import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
import { Readable } from "stream";
import { PollyServiceException as __BaseException } from "./PollyServiceException";
export interface DeleteLexiconInput {
  Name: string | undefined;
}
export interface DeleteLexiconOutput {}
export declare class LexiconNotFoundException extends __BaseException {
  readonly name: "LexiconNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LexiconNotFoundException, __BaseException>
  );
}
export declare class ServiceFailureException extends __BaseException {
  readonly name: "ServiceFailureException";
  readonly $fault: "server";
  constructor(
    opts: __ExceptionOptionType<ServiceFailureException, __BaseException>
  );
}
export declare enum Engine {
  NEURAL = "neural",
  STANDARD = "standard",
}
export declare enum LanguageCode {
  ar_AE = "ar-AE",
  arb = "arb",
  ca_ES = "ca-ES",
  cmn_CN = "cmn-CN",
  cy_GB = "cy-GB",
  da_DK = "da-DK",
  de_AT = "de-AT",
  de_DE = "de-DE",
  en_AU = "en-AU",
  en_GB = "en-GB",
  en_GB_WLS = "en-GB-WLS",
  en_IN = "en-IN",
  en_NZ = "en-NZ",
  en_US = "en-US",
  en_ZA = "en-ZA",
  es_ES = "es-ES",
  es_MX = "es-MX",
  es_US = "es-US",
  fi_FI = "fi-FI",
  fr_CA = "fr-CA",
  fr_FR = "fr-FR",
  hi_IN = "hi-IN",
  is_IS = "is-IS",
  it_IT = "it-IT",
  ja_JP = "ja-JP",
  ko_KR = "ko-KR",
  nb_NO = "nb-NO",
  nl_NL = "nl-NL",
  pl_PL = "pl-PL",
  pt_BR = "pt-BR",
  pt_PT = "pt-PT",
  ro_RO = "ro-RO",
  ru_RU = "ru-RU",
  sv_SE = "sv-SE",
  tr_TR = "tr-TR",
  yue_CN = "yue-CN",
}
export interface DescribeVoicesInput {
  Engine?: Engine | string;
  LanguageCode?: LanguageCode | string;
  IncludeAdditionalLanguageCodes?: boolean;
  NextToken?: string;
}
export declare enum Gender {
  Female = "Female",
  Male = "Male",
}
export declare enum VoiceId {
  Aditi = "Aditi",
  Adriano = "Adriano",
  Amy = "Amy",
  Andres = "Andres",
  Aria = "Aria",
  Arlet = "Arlet",
  Arthur = "Arthur",
  Astrid = "Astrid",
  Ayanda = "Ayanda",
  Bianca = "Bianca",
  Brian = "Brian",
  Camila = "Camila",
  Carla = "Carla",
  Carmen = "Carmen",
  Celine = "Celine",
  Chantal = "Chantal",
  Conchita = "Conchita",
  Cristiano = "Cristiano",
  Daniel = "Daniel",
  Dora = "Dora",
  Elin = "Elin",
  Emma = "Emma",
  Enrique = "Enrique",
  Ewa = "Ewa",
  Filiz = "Filiz",
  Gabrielle = "Gabrielle",
  Geraint = "Geraint",
  Giorgio = "Giorgio",
  Gwyneth = "Gwyneth",
  Hala = "Hala",
  Hannah = "Hannah",
  Hans = "Hans",
  Hiujin = "Hiujin",
  Ida = "Ida",
  Ines = "Ines",
  Ivy = "Ivy",
  Jacek = "Jacek",
  Jan = "Jan",
  Joanna = "Joanna",
  Joey = "Joey",
  Justin = "Justin",
  Kajal = "Kajal",
  Karl = "Karl",
  Kazuha = "Kazuha",
  Kendra = "Kendra",
  Kevin = "Kevin",
  Kimberly = "Kimberly",
  Laura = "Laura",
  Lea = "Lea",
  Liam = "Liam",
  Liv = "Liv",
  Lotte = "Lotte",
  Lucia = "Lucia",
  Lupe = "Lupe",
  Mads = "Mads",
  Maja = "Maja",
  Marlene = "Marlene",
  Mathieu = "Mathieu",
  Matthew = "Matthew",
  Maxim = "Maxim",
  Mia = "Mia",
  Miguel = "Miguel",
  Mizuki = "Mizuki",
  Naja = "Naja",
  Nicole = "Nicole",
  Ola = "Ola",
  Olivia = "Olivia",
  Pedro = "Pedro",
  Penelope = "Penelope",
  Raveena = "Raveena",
  Remi = "Remi",
  Ricardo = "Ricardo",
  Ruben = "Ruben",
  Russell = "Russell",
  Ruth = "Ruth",
  Salli = "Salli",
  Seoyeon = "Seoyeon",
  Sergio = "Sergio",
  Stephen = "Stephen",
  Suvi = "Suvi",
  Takumi = "Takumi",
  Tatyana = "Tatyana",
  Thiago = "Thiago",
  Tomoko = "Tomoko",
  Vicki = "Vicki",
  Vitoria = "Vitoria",
  Zeina = "Zeina",
  Zhiyu = "Zhiyu",
}
export interface Voice {
  Gender?: Gender | string;
  Id?: VoiceId | string;
  LanguageCode?: LanguageCode | string;
  LanguageName?: string;
  Name?: string;
  AdditionalLanguageCodes?: (LanguageCode | string)[];
  SupportedEngines?: (Engine | string)[];
}
export interface DescribeVoicesOutput {
  Voices?: Voice[];
  NextToken?: string;
}
export declare class InvalidNextTokenException extends __BaseException {
  readonly name: "InvalidNextTokenException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidNextTokenException, __BaseException>
  );
}
export declare class EngineNotSupportedException extends __BaseException {
  readonly name: "EngineNotSupportedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<EngineNotSupportedException, __BaseException>
  );
}
export interface GetLexiconInput {
  Name: string | undefined;
}
export interface Lexicon {
  Content?: string;
  Name?: string;
}
export interface LexiconAttributes {
  Alphabet?: string;
  LanguageCode?: LanguageCode | string;
  LastModified?: Date;
  LexiconArn?: string;
  LexemesCount?: number;
  Size?: number;
}
export interface GetLexiconOutput {
  Lexicon?: Lexicon;
  LexiconAttributes?: LexiconAttributes;
}
export interface GetSpeechSynthesisTaskInput {
  TaskId: string | undefined;
}
export declare enum OutputFormat {
  JSON = "json",
  MP3 = "mp3",
  OGG_VORBIS = "ogg_vorbis",
  PCM = "pcm",
}
export declare enum SpeechMarkType {
  SENTENCE = "sentence",
  SSML = "ssml",
  VISEME = "viseme",
  WORD = "word",
}
export declare enum TaskStatus {
  COMPLETED = "completed",
  FAILED = "failed",
  IN_PROGRESS = "inProgress",
  SCHEDULED = "scheduled",
}
export declare enum TextType {
  SSML = "ssml",
  TEXT = "text",
}
export interface SynthesisTask {
  Engine?: Engine | string;
  TaskId?: string;
  TaskStatus?: TaskStatus | string;
  TaskStatusReason?: string;
  OutputUri?: string;
  CreationTime?: Date;
  RequestCharacters?: number;
  SnsTopicArn?: string;
  LexiconNames?: string[];
  OutputFormat?: OutputFormat | string;
  SampleRate?: string;
  SpeechMarkTypes?: (SpeechMarkType | string)[];
  TextType?: TextType | string;
  VoiceId?: VoiceId | string;
  LanguageCode?: LanguageCode | string;
}
export interface GetSpeechSynthesisTaskOutput {
  SynthesisTask?: SynthesisTask;
}
export declare class InvalidTaskIdException extends __BaseException {
  readonly name: "InvalidTaskIdException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidTaskIdException, __BaseException>
  );
}
export declare class SynthesisTaskNotFoundException extends __BaseException {
  readonly name: "SynthesisTaskNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SynthesisTaskNotFoundException, __BaseException>
  );
}
export declare class InvalidLexiconException extends __BaseException {
  readonly name: "InvalidLexiconException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidLexiconException, __BaseException>
  );
}
export declare class InvalidS3BucketException extends __BaseException {
  readonly name: "InvalidS3BucketException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidS3BucketException, __BaseException>
  );
}
export declare class InvalidS3KeyException extends __BaseException {
  readonly name: "InvalidS3KeyException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidS3KeyException, __BaseException>
  );
}
export declare class InvalidSampleRateException extends __BaseException {
  readonly name: "InvalidSampleRateException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidSampleRateException, __BaseException>
  );
}
export declare class InvalidSnsTopicArnException extends __BaseException {
  readonly name: "InvalidSnsTopicArnException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidSnsTopicArnException, __BaseException>
  );
}
export declare class InvalidSsmlException extends __BaseException {
  readonly name: "InvalidSsmlException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidSsmlException, __BaseException>
  );
}
export declare class LanguageNotSupportedException extends __BaseException {
  readonly name: "LanguageNotSupportedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LanguageNotSupportedException, __BaseException>
  );
}
export interface LexiconDescription {
  Name?: string;
  Attributes?: LexiconAttributes;
}
export declare class LexiconSizeExceededException extends __BaseException {
  readonly name: "LexiconSizeExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LexiconSizeExceededException, __BaseException>
  );
}
export interface ListLexiconsInput {
  NextToken?: string;
}
export interface ListLexiconsOutput {
  Lexicons?: LexiconDescription[];
  NextToken?: string;
}
export interface ListSpeechSynthesisTasksInput {
  MaxResults?: number;
  NextToken?: string;
  Status?: TaskStatus | string;
}
export interface ListSpeechSynthesisTasksOutput {
  NextToken?: string;
  SynthesisTasks?: SynthesisTask[];
}
export declare class MarksNotSupportedForFormatException extends __BaseException {
  readonly name: "MarksNotSupportedForFormatException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      MarksNotSupportedForFormatException,
      __BaseException
    >
  );
}
export declare class MaxLexemeLengthExceededException extends __BaseException {
  readonly name: "MaxLexemeLengthExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      MaxLexemeLengthExceededException,
      __BaseException
    >
  );
}
export declare class MaxLexiconsNumberExceededException extends __BaseException {
  readonly name: "MaxLexiconsNumberExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      MaxLexiconsNumberExceededException,
      __BaseException
    >
  );
}
export interface PutLexiconInput {
  Name: string | undefined;
  Content: string | undefined;
}
export interface PutLexiconOutput {}
export declare class UnsupportedPlsAlphabetException extends __BaseException {
  readonly name: "UnsupportedPlsAlphabetException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      UnsupportedPlsAlphabetException,
      __BaseException
    >
  );
}
export declare class UnsupportedPlsLanguageException extends __BaseException {
  readonly name: "UnsupportedPlsLanguageException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      UnsupportedPlsLanguageException,
      __BaseException
    >
  );
}
export declare class SsmlMarksNotSupportedForTextTypeException extends __BaseException {
  readonly name: "SsmlMarksNotSupportedForTextTypeException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      SsmlMarksNotSupportedForTextTypeException,
      __BaseException
    >
  );
}
export interface StartSpeechSynthesisTaskInput {
  Engine?: Engine | string;
  LanguageCode?: LanguageCode | string;
  LexiconNames?: string[];
  OutputFormat: OutputFormat | string | undefined;
  OutputS3BucketName: string | undefined;
  OutputS3KeyPrefix?: string;
  SampleRate?: string;
  SnsTopicArn?: string;
  SpeechMarkTypes?: (SpeechMarkType | string)[];
  Text: string | undefined;
  TextType?: TextType | string;
  VoiceId: VoiceId | string | undefined;
}
export interface StartSpeechSynthesisTaskOutput {
  SynthesisTask?: SynthesisTask;
}
export declare class TextLengthExceededException extends __BaseException {
  readonly name: "TextLengthExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TextLengthExceededException, __BaseException>
  );
}
export interface SynthesizeSpeechInput {
  Engine?: Engine | string;
  LanguageCode?: LanguageCode | string;
  LexiconNames?: string[];
  OutputFormat: OutputFormat | string | undefined;
  SampleRate?: string;
  SpeechMarkTypes?: (SpeechMarkType | string)[];
  Text: string | undefined;
  TextType?: TextType | string;
  VoiceId: VoiceId | string | undefined;
}
export interface SynthesizeSpeechOutput {
  AudioStream?: Readable | ReadableStream | Blob;
  ContentType?: string;
  RequestCharacters?: number;
}
export declare const DeleteLexiconInputFilterSensitiveLog: (
  obj: DeleteLexiconInput
) => any;
export declare const DeleteLexiconOutputFilterSensitiveLog: (
  obj: DeleteLexiconOutput
) => any;
export declare const DescribeVoicesInputFilterSensitiveLog: (
  obj: DescribeVoicesInput
) => any;
export declare const VoiceFilterSensitiveLog: (obj: Voice) => any;
export declare const DescribeVoicesOutputFilterSensitiveLog: (
  obj: DescribeVoicesOutput
) => any;
export declare const GetLexiconInputFilterSensitiveLog: (
  obj: GetLexiconInput
) => any;
export declare const LexiconFilterSensitiveLog: (obj: Lexicon) => any;
export declare const LexiconAttributesFilterSensitiveLog: (
  obj: LexiconAttributes
) => any;
export declare const GetLexiconOutputFilterSensitiveLog: (
  obj: GetLexiconOutput
) => any;
export declare const GetSpeechSynthesisTaskInputFilterSensitiveLog: (
  obj: GetSpeechSynthesisTaskInput
) => any;
export declare const SynthesisTaskFilterSensitiveLog: (
  obj: SynthesisTask
) => any;
export declare const GetSpeechSynthesisTaskOutputFilterSensitiveLog: (
  obj: GetSpeechSynthesisTaskOutput
) => any;
export declare const LexiconDescriptionFilterSensitiveLog: (
  obj: LexiconDescription
) => any;
export declare const ListLexiconsInputFilterSensitiveLog: (
  obj: ListLexiconsInput
) => any;
export declare const ListLexiconsOutputFilterSensitiveLog: (
  obj: ListLexiconsOutput
) => any;
export declare const ListSpeechSynthesisTasksInputFilterSensitiveLog: (
  obj: ListSpeechSynthesisTasksInput
) => any;
export declare const ListSpeechSynthesisTasksOutputFilterSensitiveLog: (
  obj: ListSpeechSynthesisTasksOutput
) => any;
export declare const PutLexiconInputFilterSensitiveLog: (
  obj: PutLexiconInput
) => any;
export declare const PutLexiconOutputFilterSensitiveLog: (
  obj: PutLexiconOutput
) => any;
export declare const StartSpeechSynthesisTaskInputFilterSensitiveLog: (
  obj: StartSpeechSynthesisTaskInput
) => any;
export declare const StartSpeechSynthesisTaskOutputFilterSensitiveLog: (
  obj: StartSpeechSynthesisTaskOutput
) => any;
export declare const SynthesizeSpeechInputFilterSensitiveLog: (
  obj: SynthesizeSpeechInput
) => any;
export declare const SynthesizeSpeechOutputFilterSensitiveLog: (
  obj: SynthesizeSpeechOutput
) => any;
